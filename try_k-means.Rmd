---
title: "Try your data"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.width = 8,
                      fig.show = 'animation',
                      results = 'hide')

library(tidyverse)
library(gganimate)
library(animation)

source("helper_functions.R")

# Set size of animation window
ani.options(ani.width = 780)
```

## 1. Prepare your data

#### a) Initialize dataset as tibble of two variables
```{r}
set.seed(1234)
x <- rnorm(12, mean = rep(1:3, each = 4), sd = 1)
y <- rnorm(12, mean = rep(c(1, 2, 1), each = 4), sd = 1)
df_xy <- tibble(x, y)
```
#### b) Set initial coordinates of cluster`s centers and their identificators
```{r}
Cx = c(1, 1.6, 3.5)
Cy = c(1, 2.0, 0.6)
# Number of clusters define as length of Cx or Cy vectors
n_clust <- length(Cx)
df_cl <- tibble(Cluster = factor(seq(n_clust), ordered = T), Cx, Cy)
```
#### c) Make dataset that connect our points with initial cluster's
```{r}
df_kmeans0 <- bind_cols(df_xy, map_dfr(df_cl, rep, each = length(x) / n_clust))
```
#### d) Now, take a look at the initial configuration of the clusters
```{r}
ggplot(df_kmeans0, aes(x, y)) +
  geom_point(shape = 1, size = 5, stroke = 1) +
  geom_text(aes(x, y, label = rownames(df_xy)), vjust = 2.0, size = 4, color = "black") + 
  geom_point(aes(Cx, Cy, color = Cluster), shape = 3, size = 5, stroke = 1) +
  labs(title = "The initial location of the cluster centers") +
  theme(plot.title = element_text(hjust = 0.5))
```
## 2. Run k-means algorithm

#### a) Get dataset with k-means iterations 
```{r}
n_iter <- 5 # nubmer of k-means iterations
df_kmeans <- wraper_kmeans(df_xy, df_cl, n_iter)
```
#### b) View main results of k_means algorithm for chosen iteration
```{r warning=FALSE, paged.print=FALSE}
my_kmeans <- get_kmeans(n_iter, df_kmeans)
my_kmeans
```
#### c) Get result from build-in k-means() function
```{r}
kmeans(x = as.matrix(df_xy), centers = cbind(Cx, Cy),
       iter.max = n_iter, algorithm = "Forgy")
```
## 3. Visualize results

#### a) Make "long" dataframe from the df_kmeans list
```{r}
df_long <- map_dfr(df_kmeans, ~ .)
```
#### b) Visualize clusters as poligons, animate points accesory to clusters (by changing color) and centers of clusters
```{r message=FALSE, warning=FALSE}
theme_ani <- theme(
          plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
          legend.title = element_text(face = "bold", colour = "black", size = 12),
          legend.text = element_text(size = 11, color = "black"),
          axis.text = element_text(size = 11, colour = "black"),
          axis.title = element_text(size = 12, face = "bold"))

ggplot(df_long, aes(x, y, color = Cluster, frame = Iteration)) +
  geom_point(aes(group = Cluster), size = 5) +
  geom_point(aes(x = Cx, y = Cy), shape = 3, size = 5, color = "black", stroke = 1) +
  geom_path(aes(x = Cx, y = Cy, cumulative = TRUE, group = Cluster),
            color = "black") +
  geom_text(aes(x, y, label = rowid), vjust = 1.8, size = 4, color = 'black') +
  geom_polygon(data = df_polygon(df_kmeans),
               aes(x, y, group = Cluster, fill = Cluster), alpha = .5) +
  labs(title = "How k-means work:") +
  theme_ani -> gg

gganimate(gg)
```
```{r}
ggplot(df_long, aes(x = rowid, y = Eu_dist, frame = Iteration, cumulative = TRUE)) +
  geom_point(aes(color = Iteration), size = 5) +
  geom_line(aes(color = Iteration), size = 1) +
  scale_x_continuous(breaks = 1:dim(df_xy)[1]) +
  labs(x = "Points", y = "Euclidean distance",
       title = "Euclidean distance for each points on:") +
  theme_ani -> gg_dist

gganimate(gg_dist)
```
#### **Comment#1**  

[//]: # (На самкінець хочу зазначити деякі речі. Це - демонстраційний приклад,
тому алгоритм k-means, реалізований тут, може бути далеким від ефективності.
Саме тому я не рекомендую використувовати його з великими датасетами і великою
кількістю ітерацій (> 10). Звичайно, ви можете використати свій власний датасет,
якщо вам це цікаво)

By the end I want to mention some things.   
This is a demonstration example, so the k-means algorithm implemented here may be far from effective. Because of this, I do not recommend using it with large datasets and a large number of iterations (> 10). Of course, you can use your own dataset if you are interested.   

#### **Comment#2**   

So, what have I achieved by reinventing the wheel:   
1.  Understood the [k-means](https://en.wikipedia.org/wiki/K-means_clustering) algorithm, of course)   
2.  Improved my skills in [tydiverse](https://www.tidyverse.org/)   
3.  Learned to write recursive functions that return two values, one of which is necessary for recursion work, and the other - for external needs. This was achieved by the additional wrapper function and the concept of environments.  
4.  Learned to make animated charts with [gganimate](https://github.com/thomasp85/gganimate).  
5.  Examined [chull](https://www.rdocumentation.org/packages/grDevices/versions/3.5.1/topics/chull) function from base R   
6.  Learned how to [hide comments](https://stackoverflow.com/questions/4823468/comments-in-markdown) in [Rmarkdown](https://rmarkdown.rstudio.com/index.html)  
    
I'd be appriciate for your critical remarks and comments. Well, of course I will be very-very-very happy if this material helps you understand k-means as it helped me!
   
   
[//]: # (Отже, чому я навчився, заново "винайшовши велосипед":   
1.Розібрався з алгоритмом k-means
2.Непогано прокачав свої скіли в tydiverse  
3.Навчився писати рекурсивні функції, що повертають два значення, одне з яких необхідне для роботи рекурсії, а інше - для зовнішніх потреб. Цього я досяг за допомогою додаткової функції-обгортки та поняття environments.  
4.Навчився робити анімаційні графіки за допомогою gganimate
5.Познайомився з функцією chull
6.Як приховувати коменти в Rmarkdown
Буду радий почути критичні зауваження, коментарі. Ну і буду дуже-дуже-дуже радий, якщо цей матеріал допоможе вам у розумінні k-means, як він допоміг мені)
  
